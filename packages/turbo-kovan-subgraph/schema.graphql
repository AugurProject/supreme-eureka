type AmmFactory @entity {
  id: ID!
  blockHash: String!
  blockNumber: Int!
  logIndex: Int!
  "A composite key of blockNumber+logIndex used for easily paging through logs"
  logPosition: String!
  name: String!
  transactionHash: String!
  origin: String!
  pool: String!
  marketFactory: String!
  marketId: Int!
  creator: String!
  lpTokenRecipient: String!
}

type Market @entity {
  id: ID!
  liquidity: [Liquidity!] @derivedFrom(field: "marketId")
  addLiquidity: [AddLiquidity!] @derivedFrom(field: "marketId")
  removeLiquidity: [RemoveLiquidity!] @derivedFrom(field: "marketId")
  trades: [Trade!] @derivedFrom(field: "marketId")
  claimedProceeds: [ClaimedProceeds!] @derivedFrom(field: "marketId")
}

type Liquidity @entity {
  id: ID!
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  marketFactory: String!
  sender: Sender!
  recipient: String!
  "From the perspective of the user. E.g. collateral is negative when adding liquidity."
  collateral: String!
  lpTokens: String!
  sharesReturned: [BigInt!]
  totalSupply: BigInt
}

type Sender @entity {
  id: ID!
  addLiquidity: [AddLiquidity!] @derivedFrom(field: "sender")
  removeLiquidity: [RemoveLiquidity!] @derivedFrom(field: "sender")
  claimedProceeds: [ClaimedProceeds!] @derivedFrom(field: "sender")
  claimedFees: [ClaimedFees!] @derivedFrom(field: "sender")
  trade: [Trade!] @derivedFrom(field: "sender")
  positionBalance: [PositionBalance!] @derivedFrom(field: "sender")
  "From the perspective of the user. E.g. totalLiquidity is negative when adding liquidity."
  totalLiquidity: BigInt
  sumOfInitialCost: [InitialCostPerMarket!] @derivedFrom(field: "sender")
}

type AddLiquidity @entity {
  id: ID!
  sender: Sender!
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  collateral: String!
  lpTokens: String!
  sharesReturned: [BigInt!]
  totalSupply: BigInt
}

type Outcomes @entity {
  id: ID!
  amount: String
  addLiquidity: AddLiquidity
  removeLiquidity: RemoveLiquidity
}

type RemoveLiquidity @entity {
  id: ID!
  sender: Sender!
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "removeLiquidity")
  collateral: String!
  lpTokens: String!
  sharesReturned: [BigInt!]
  totalSupply: BigInt
}

type Trade @entity {
  id: ID!
  marketId: Market!
  marketFactory: String!
  user: String!
  sender: Sender!
  outcome: String!
  "From the perspective of the user. E.g. collateral is negative when buying."
  collateral: String!
  shares: String!
  price: BigDecimal!
  transactionHash: String!
  timestamp: BigInt!
}

type ClaimedProceeds @entity {
  id: ID!
  sender: Sender!
  fees: String!
  outcome: String!
  marketId: Market
  payout: String!
  shares: String!
  transactionHash: String!
  timestamp: BigInt!
}

type ClaimedFees @entity {
  id: ID!
  sender: Sender!
  collateral: String!
  receiver: String!
  transactionHash: String!
  timestamp: BigInt!
}

#
#event LiquidityChanged(
#  address indexed marketFactory,
#  uint256 indexed marketId,
#  address indexed user,
#  address recipient,
#  // from the perspective of the user. e.g. collateral is negative when adding liquidity
#  int256 collateral,
#  int256 lpTokens,
#  uint256[] sharesReturned
#);
#
#event SharesSwapped(
#  address indexed marketFactory,
#  uint256 indexed marketId,
#  address indexed user,
#  uint256 outcome,
#  // from the perspective of the user. e.g. collateral is negative when buying
#  int256 collateral,
#  int256 shares,
#  uint256 price
#);

type PositionBalance @entity {
  id: ID!
  positionFromAddLiquidity: Boolean # did the user get a position from adding liquidity
  positionFromRemoveLiquidity: Boolean # did the user get a position from removing liquidity
  hasClaimed: Boolean # has the user claimed winnings
  timestamp: BigInt! # last timestamp that effected user's position
  transactionHash: String!
  outcomeId: String # market outcome id
  # total paid / shares
  avgPrice: BigDecimal # average price user paid
  # price * shares
  initCostUsd: String # total cost in usdc, user paid
  initCostUsdBigInt: BigInt
  initCostUsdBigDecimal: BigDecimal
  shares: String # number of shares
  sharesBigInt: BigInt
  sharesBigDecimal: BigDecimal
  payout: String
  payoutBigInt: BigInt
  payoutBigDecimal: BigDecimal
  sender: Sender!
  market: Market!
  totalChangeUsd: String
  totalChangeUsdBigInt: BigInt
  totalChangeUsdBigDecimal: BigDecimal
}

type InitialCostPerMarket @entity {
  id: ID!
  sender: Sender
  market: Market
  sumOfInitialCost: BigInt!
}